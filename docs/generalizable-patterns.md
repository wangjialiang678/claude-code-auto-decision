# 可泛化的工作模式与能力

本文档总结了从本项目中提炼出的可泛化能力，可应用于其他项目和对话。

## 一、任务管理模式

### 1.1 完成检查清单模式 ⭐⭐⭐⭐⭐

**适用场景**：所有涉及交付的任务

**核心思想**：任务不是"做完"就结束，而是"交付"才算完成

**标准清单**：
```markdown
## 任务完成检查清单

### 阶段 1: 功能验证
- [ ] 运行所有测试
- [ ] 运行新创建的工具/功能
- [ ] 验证核心功能正常工作

### 阶段 2: 关联检查
- [ ] 相关文档是否需要更新？
- [ ] 相关配置是否需要调整？
- [ ] 相关工具/脚本是否需要更新？
- [ ] 用户手册/README 是否需要更新？

### 阶段 3: 集成验证
- [ ] 新功能与现有系统的集成是否正常？
- [ ] 是否影响了其他功能？
- [ ] 版本控制状态是否正确？

### 阶段 4: 用户交付
- [ ] 生成验证报告
- [ ] 说明如何使用新功能
- [ ] 说明下次如何更新/维护
- [ ] 提供回滚方案（如适用）
```

**Todo 模式**：
```
最后一个 todo 总是：
"生成验证报告和使用说明"
```

**泛化能力**：
- ✅ 适用于任何编程项目
- ✅ 适用于文档编写
- ✅ 适用于配置管理
- ✅ 适用于系统部署

---

### 1.2 关联性检查模式 ⭐⭐⭐⭐⭐

**适用场景**：创建/修改任何文件时

**核心思想**：文件之间存在关联，修改一处要检查相关文件

**检查矩阵**：

| 修改内容 | 需要检查的关联文件 |
|---------|------------------|
| 添加新工具 | README, 相关 skills, 测试脚本, 文档 |
| 修改 API | 调用方代码, 文档, 测试用例 |
| 添加配置项 | 配置文档, 默认配置模板, 迁移脚本 |
| 修改数据结构 | 数据库 schema, 序列化/反序列化代码, 测试数据 |
| 添加依赖 | package.json, requirements.txt, README 安装说明 |

**具体应用**：
```python
# 伪代码：关联检查函数
def check_associations(changed_file):
    associations = {
        'tools/*.sh': ['README.md', 'skills/*/SKILL.md', 'docs/*.md'],
        'src/api/*.py': ['tests/*.py', 'docs/api.md', 'openapi.yaml'],
        'config/*.json': ['docs/configuration.md', 'config/example.json'],
    }

    for pattern, related_files in associations.items():
        if matches(changed_file, pattern):
            for f in related_files:
                check_if_update_needed(f)
```

**泛化能力**：
- ✅ 适用于任何有文档的项目
- ✅ 适用于有配置文件的系统
- ✅ 适用于有测试的代码库
- ✅ 适用于团队协作项目

---

### 1.3 验证驱动交付模式 ⭐⭐⭐⭐

**适用场景**：所有部署/发布任务

**核心思想**：不假设成功，要验证成功

**验证层次**：
```
1. 单元验证（功能本身）
   ├─ 运行测试
   ├─ 手动试用
   └─ 检查日志

2. 集成验证（与系统的集成）
   ├─ 运行集成测试
   ├─ 检查依赖关系
   └─ 验证配置正确

3. 部署验证（部署是否成功）
   ├─ 检查文件是否存在
   ├─ 检查版本是否正确
   └─ 检查服务是否运行

4. 同步验证（版本控制）
   ├─ git status (clean?)
   ├─ git diff local remote (同步?)
   └─ 检查分支状态
```

**实践建议**：
- git push 后：验证 `git rev-parse HEAD origin/main`
- 部署后：运行验证脚本（如 check-updates.sh）
- 发布后：生成验证报告

**泛化能力**：
- ✅ 适用于任何部署场景
- ✅ 适用于 CI/CD 流程
- ✅ 适用于发布管理
- ✅ 适用于数据迁移

---

## 二、代码质量模式

### 2.1 测试先行模式 ⭐⭐⭐⭐⭐

**适用场景**：所有代码开发

**核心思想**：写完代码立即写测试，不要等到最后

**本项目示例**：
- 创建 hooks → 立即创建 test_hooks.py
- 修改规则系统 → 立即测试规则加载/匹配
- 添加新功能 → 在测试中验证

**测试类型**：
```python
# 1. 单元测试（功能正确性）
def test_rule_loading():
    rules = load_rules()
    assert len(rules) > 0
    assert no_duplicates(rules)

# 2. 集成测试（与系统的集成）
def test_grep_command_allowed():
    action = match_rules("Bash", {"command": "grep test"})
    assert action == "allow"

# 3. 回归测试（防止破坏现有功能）
def test_env_file_protection():
    action = match_rules("Write", {"file_path": ".env"})
    assert action == "deny"
```

**泛化能力**：
- ✅ 适用于任何编程语言
- ✅ 适用于任何项目规模
- ✅ 适用于重构场景
- ✅ 适用于 bug 修复

---

### 2.2 优先级驱动设计模式 ⭐⭐⭐⭐

**适用场景**：有规则/配置系统的项目

**核心思想**：明确定义优先级，让系统行为可预测

**本项目示例**：
```
规则文件优先级:
  1. 项目 learned-rules.md  (最高)
  2. 项目 rules.md
  3. 全局 learned-rules.md
  4. 全局 rules.md          (最低)

文件内优先级:
  - deny 规则在前
  - 特定规则在前
  - 通用规则在后
```

**设计原则**：
1. 优先级必须文档化
2. 优先级必须可测试
3. 冲突必须有明确的解决策略
4. 用户可以理解和预测系统行为

**泛化应用**：
- CSS 样式优先级
- 路由匹配优先级
- 权限检查优先级
- 配置合并优先级

**泛化能力**：
- ✅ 适用于配置系统
- ✅ 适用于规则引擎
- ✅ 适用于中间件系统
- ✅ 适用于策略模式

---

### 2.3 冲突检测与处理模式 ⭐⭐⭐⭐

**适用场景**：有多来源配置/规则的系统

**核心思想**：主动检测冲突，不要等到运行时才发现

**检测策略**：
```python
def load_with_conflict_detection():
    seen = {}
    for source in priority_order:
        for item in load_from(source):
            key = generate_key(item)
            if key in seen:
                handle_conflict(seen[key], item)
            else:
                seen[key] = item
```

**冲突处理策略**：
1. **忽略低优先级**（本项目采用）
2. **合并策略**（如配置合并）
3. **报错终止**（如编译错误）
4. **用户选择**（交互式解决）

**日志记录**：
- 总是记录冲突到日志
- 说明冲突的来源和优先级
- 说明最终采用的规则

**泛化能力**：
- ✅ 适用于配置管理
- ✅ 适用于依赖解析
- ✅ 适用于数据合并
- ✅ 适用于版本控制

---

## 三、文档模式

### 3.1 分层文档模式 ⭐⭐⭐⭐⭐

**适用场景**：任何需要文档的项目

**核心思想**：不同层次的文档服务不同的读者

**文档层次**：
```
1. README.md (快速开始)
   ├─ 项目简介
   ├─ 快速安装
   ├─ 基本使用
   └─ 核心概念

2. docs/guide.md (深入理解)
   ├─ 架构设计
   ├─ 工作原理
   ├─ 最佳实践
   └─ 常见问题

3. docs/api.md (API 参考)
   ├─ 函数签名
   ├─ 参数说明
   ├─ 返回值
   └─ 示例代码

4. docs/development.md (开发指南)
   ├─ 代码结构
   ├─ 贡献指南
   ├─ 测试说明
   └─ 发布流程

5. docs/strategy.md (决策文档)
   ├─ 设计决策
   ├─ 权衡考虑
   ├─ 替代方案
   └─ 未来规划
```

**本项目示例**：
- README.md: 快速理解系统
- test-cases.md: 测试指南
- update-strategy.md: 更新策略（决策文档）
- dev-history.md: 开发历史

**泛化能力**：
- ✅ 适用于任何项目
- ✅ 适用于库/框架
- ✅ 适用于服务/应用
- ✅ 适用于内部工具

---

### 3.2 决策文档模式 ⭐⭐⭐⭐

**适用场景**：有多种实现方案的场景

**核心思想**：记录"为什么"而不只是"是什么"

**文档结构**：
```markdown
# 决策：XXX 功能的实现方案

## 问题描述
sync.sh 保留用户配置会导致更新困难

## 候选方案

### 方案 1: 手动合并
**优点**: ...
**缺点**: ...
**适用场景**: ...

### 方案 2: 分层规则文件
**优点**: ...
**缺点**: ...
**实现难度**: ...

### 方案 3: 版本检测
**优点**: ...
**缺点**: ...

## 决策结果
采用方案 1（当前推荐），未来迁移到方案 2

## 理由
...

## 未来改进
...
```

**价值**：
- 新成员可以理解设计思路
- 未来重构时有参考
- 避免重复讨论已解决的问题

**泛化能力**：
- ✅ 适用于架构设计
- ✅ 适用于技术选型
- ✅ 适用于重构决策
- ✅ 适用于团队协作

---

## 四、工具模式

### 4.1 自动化检查工具模式 ⭐⭐⭐⭐⭐

**适用场景**：任何需要定期检查的场景

**核心思想**：不要依赖人记住检查，让工具自动检查

**本项目示例**：check-updates.sh

**通用模板**：
```bash
#!/bin/bash
# check-xxx.sh - 自动检查工具

# 1. 检查 A
check_a() {
    if condition; then
        echo "✓ A 正常"
        return 0
    else
        echo "⚠ A 有问题"
        echo "建议: ..."
        return 1
    fi
}

# 2. 检查 B
check_b() { ... }

# 3. 生成报告
print_summary() {
    echo "检查摘要:"
    [ $a_ok -eq 0 ] && echo "  ✓ A" || echo "  ✗ A"
    [ $b_ok -eq 0 ] && echo "  ✓ B" || echo "  ✗ B"

    if [ $a_ok -ne 0 ] || [ $b_ok -ne 0 ]; then
        echo ""
        echo "建议操作:"
        [ $a_ok -ne 0 ] && echo "  1. 修复 A"
        [ $b_ok -ne 0 ] && echo "  2. 修复 B"
    fi
}
```

**检查工具的通用特征**：
- 彩色输出（成功 = 绿色，警告 = 黄色，错误 = 红色）
- 摘要报告（一目了然的状态）
- 具体建议（告诉用户怎么修复）
- 自动化友好（可以在 CI 中运行）

**泛化应用**：
- check-security.sh（安全检查）
- check-dependencies.sh（依赖检查）
- check-performance.sh（性能检查）
- check-config.sh（配置检查）

**泛化能力**：
- ✅ 适用于任何项目
- ✅ 适用于 CI/CD
- ✅ 适用于运维检查
- ✅ 适用于代码质量

---

### 4.2 测试脚本模式 ⭐⭐⭐⭐⭐

**适用场景**：所有有代码的项目

**核心思想**：测试应该易于运行、理解和扩展

**本项目示例**：test_hooks.py

**好的测试脚本特征**：
```python
# 1. 独立性（可单独运行）
if __name__ == "__main__":
    sys.exit(main())

# 2. 清晰的输出
print(f"=== 测试 1: 规则加载 ===")
print(f"✓ 成功加载 {len(rules)} 条规则")

# 3. 明确的断言
status = "✓" if action == expected else "✗"
print(f"{status} {desc}: {action} (期望: {expected})")

# 4. 汇总报告
print("\n测试结果汇总:")
for name, passed in results:
    status = "✓ 通过" if passed else "✗ 失败"
    print(f"{status} - {name}")
```

**测试组织**：
- 每个测试一个函数
- 测试之间互不依赖
- 测试名称描述测试内容
- 返回 0 (成功) 或 1 (失败)

**泛化能力**：
- ✅ 适用于任何语言
- ✅ 适用于任何项目
- ✅ 可集成到 CI
- ✅ 可作为回归测试

---

## 五、Skills/自动化模式

### 5.1 Skill 触发模式 ⭐⭐⭐⭐

**适用场景**：需要 AI 自动响应的场景

**核心思想**：定义清晰的触发条件和执行步骤

**Skill 模板**：
```markdown
# XXX Skill

简短描述这个 skill 的作用

## 触发条件

当用户说以下内容时自动触发：
- "关键词 1"、"关键词 2"
- 英文关键词
- 相关动词

## 执行步骤

### 方式 1: 自动化方式（推荐）
1. 运行检查工具
2. 显示结果
3. 给出建议

### 方式 2: 交互方式
1. 询问用户需求
2. 执行操作
3. 确认结果

## 重要提示

需要特别注意的事项

## 命令参考

具体的命令示例
```

**设计原则**：
- 触发条件要广泛（多种表达方式）
- 执行步骤要明确（可操作）
- 要有容错处理（如工具不存在）
- 要给用户选择（自动 vs 手动）

**泛化能力**：
- ✅ 适用于任何 AI 辅助场景
- ✅ 适用于自动化任务
- ✅ 适用于定期维护
- ✅ 适用于最佳实践传播

---

## 六、版本管理模式

### 6.1 分层配置模式 ⭐⭐⭐⭐

**适用场景**：有用户自定义配置的系统

**核心思想**：分离"项目默认"和"用户自定义"

**本项目问题**：
- rules.md 混合了默认和用户自定义
- 更新时难以合并

**改进方案**（未来实现）：
```
~/.claude/memory-bank/
├── rules.md         # 项目默认（可覆盖）
└── custom-rules.md  # 用户自定义（不覆盖）
```

**加载优先级**：
```
1. 项目 custom-rules.md  (最高)
2. 项目 rules.md
3. 全局 custom-rules.md
4. 全局 rules.md          (最低)
```

**泛化应用**：
```
配置系统:
├── config.default.json   # 默认配置
└── config.user.json      # 用户配置

插件系统:
├── plugins/official/     # 官方插件
└── plugins/custom/       # 用户插件

样式系统:
├── styles/base.css       # 基础样式
└── styles/custom.css     # 用户样式
```

**泛化能力**：
- ✅ 适用于配置管理
- ✅ 适用于插件系统
- ✅ 适用于主题系统
- ✅ 适用于规则引擎

---

### 6.2 版本检测模式 ⭐⭐⭐⭐

**适用场景**：需要更新/迁移的系统

**核心思想**：文件包含版本信息，便于检测和迁移

**实现方式**：
```markdown
# 配置文件
# Version: 1.2.0
# Last-Update: 2026-01-23

{
  "version": "1.2.0",
  "data": {...}
}
```

**检测逻辑**：
```python
def check_version(file_path):
    current = read_version(file_path)
    latest = get_latest_version()

    if current < latest:
        print(f"发现新版本: {current} → {latest}")
        print("变更内容:")
        print_changelog(current, latest)

        action = prompt_user([
            "自动升级",
            "手动合并",
            "跳过"
        ])

        if action == "自动升级":
            backup(file_path)
            migrate(file_path, latest)
```

**泛化能力**：
- ✅ 适用于配置文件
- ✅ 适用于数据库 schema
- ✅ 适用于 API 版本
- ✅ 适用于文件格式

---

## 七、总结：可泛化的核心能力

### 高价值能力（5 星，立即应用）

1. **完成检查清单模式** - 确保交付质量
2. **关联性检查模式** - 避免遗漏相关文件
3. **测试先行模式** - 保证代码质量
4. **自动化检查工具模式** - 减少人工检查
5. **测试脚本模式** - 快速验证功能
6. **分层文档模式** - 服务不同读者

### 中等价值能力（4 星，选择应用）

1. **验证驱动交付模式** - 适用于部署场景
2. **优先级驱动设计模式** - 适用于配置系统
3. **冲突检测与处理模式** - 适用于多源配置
4. **决策文档模式** - 适用于复杂决策
5. **Skill 触发模式** - 适用于 AI 自动化
6. **分层配置模式** - 适用于可定制系统
7. **版本检测模式** - 适用于需要迁移的系统

---

## 应用到其他项目的行动清单

### 新项目启动时

- [ ] 创建 README.md（包含快速开始）
- [ ] 创建 test/ 目录（准备测试）
- [ ] 创建 docs/ 目录（分层文档）
- [ ] 添加 check-xxx.sh（检查工具）
- [ ] 定义优先级规则（如适用）

### 开发过程中

- [ ] 每次创建新功能，立即写测试
- [ ] 每次修改文件，检查关联文件
- [ ] 使用 TodoWrite，最后一项是验证
- [ ] 重要决策写到 docs/decisions/

### 交付前

- [ ] 运行完成检查清单
- [ ] 生成验证报告
- [ ] 更新 README（如有新功能）
- [ ] 检查 Git 同步状态

---

## 在新对话中应用这些模式

### AI 侧（我的行为）

**自动应用**：
- 创建任务时自动添加"验证和报告" todo
- 完成功能后自动运行测试
- git push 后自动验证同步
- 部署后自动生成验证报告

**主动检查**：
- 创建新文件时，检查关联文件
- 修改代码时，检查测试是否需要更新
- 添加配置时，检查文档是否需要更新

**交付标准**：
- 不只是"功能完成"
- 而是"用户可以使用"
- 包含：验证报告 + 使用说明 + 维护指南

### 用户侧（你的检查点）

**可以要求的**：
- "运行验证清单"
- "检查关联文件"
- "生成使用说明"
- "确认 Git 同步"

**可以期待的**：
- 自动生成测试
- 主动更新文档
- 主动检查冲突
- 主动验证部署

---

## 附录：模式速查表

| 场景 | 使用模式 | 关键要点 |
|------|---------|---------|
| 完成任务 | 完成检查清单 | 最后一步总是验证 |
| 创建文件 | 关联性检查 | 检查相关文件 |
| 写代码 | 测试先行 | 立即写测试 |
| 部署 | 验证驱动交付 | 不假设成功 |
| 配置系统 | 优先级驱动 | 明确优先级 |
| 多源配置 | 冲突检测 | 主动检测冲突 |
| 写文档 | 分层文档 | 服务不同读者 |
| 重要决策 | 决策文档 | 记录为什么 |
| 定期检查 | 自动化工具 | 让工具检查 |
| AI 自动化 | Skill 模式 | 清晰的触发条件 |
| 用户配置 | 分层配置 | 分离默认和自定义 |
| 版本升级 | 版本检测 | 文件含版本号 |
